import random
import numpy as np

np.random.seed(0)
random.seed(0)

from pyomo.core import *

def define_stochastic_model():

    #
    # Model
    #

    model = ConcreteModel()

    #
    # Sets
    #

    model.CROPS = Set(initialize=['WHEAT','CORN','SUGAR_BEETS'])

    #
    # Parameters
    #

    model.TOTAL_ACREAGE = 500.0
    model.PriceQuota = {'WHEAT':100000.0,'CORN':100000.0,'SUGAR_BEETS':6000.0}
    model.SubQuotaSellingPrice = {'WHEAT':170.0,'CORN':150.0,'SUGAR_BEETS':36.0}
    model.SuperQuotaSellingPrice = {'WHEAT':0.0,'CORN':0.0,'SUGAR_BEETS':10.0}
    model.CattleFeedRequirement = {'WHEAT':200.0,'CORN':240.0,'SUGAR_BEETS':0.0}
    model.PurchasePrice = {'WHEAT':238.0,'CORN':210.0,'SUGAR_BEETS':100000.0}
    model.PlantingCostPerAcre = {'WHEAT':150.0,'CORN':230.0,'SUGAR_BEETS':260.0}

    #
    # This parameter will be stochastic so it must be mutable
    # and initialized with a nonzero value
    #
    model.Yield = Param(model.CROPS,
                        within=NonNegativeReals,
                        initialize=1.0,
                        mutable=True)

    #
    # Variables
    #

    model.DevotedAcreage = Var(model.CROPS, bounds=(0.0, model.TOTAL_ACREAGE))
    model.QuantitySubQuotaSold = Var(model.CROPS, bounds=(0.0, None))
    model.QuantitySuperQuotaSold = Var(model.CROPS, bounds=(0.0, None))
    model.QuantityPurchased = Var(model.CROPS, bounds=(0.0, None))

    #
    # Constraints
    #

    model.ConstrainTotalAcreage = \
        Constraint(expr=summation(model.DevotedAcreage) <= model.TOTAL_ACREAGE)

    def EnforceCattleFeedRequirement_rule(m, i):
        return m.CattleFeedRequirement[i] <= \
            (m.Yield[i] * m.DevotedAcreage[i]) + \
            m.QuantityPurchased[i] - m.QuantitySubQuotaSold[i] - \
            m.QuantitySuperQuotaSold[i]
    model.EnforceCattleFeedRequirement = \
        Constraint(model.CROPS, rule=EnforceCattleFeedRequirement_rule)

    def LimitAmountSold_rule(m, i):
        return m.QuantitySubQuotaSold[i] + \
               m.QuantitySuperQuotaSold[i] - \
               (m.Yield[i] * m.DevotedAcreage[i]) <= 0.0
    model.LimitAmountSold = Constraint(model.CROPS, rule=LimitAmountSold_rule)

    def EnforceQuotas_rule(m, i):
        return 0.0 <= m.QuantitySubQuotaSold[i] <= m.PriceQuota[i]
    model.EnforceQuotas = Constraint(model.CROPS, rule=EnforceQuotas_rule)

    #
    # Stage-specific cost computations
    #

    model.FirstStageCost = \
        Expression(expr=summation(model.PlantingCostPerAcre, model.DevotedAcreage))

    model.SecondStageCost = \
        Expression(expr=summation(model.PurchasePrice, model.QuantityPurchased) - \
                        summation(model.SubQuotaSellingPrice, model.QuantitySubQuotaSold) - \
                        summation(model.SuperQuotaSellingPrice, model.QuantitySuperQuotaSold))

    #
    # PySP Auto-generated Objective
    #
    # minimize: sum of StageCostVariables
    #
    # An active scenario objective equivalent to that generated by PySP is
    # included here for informational purposes.
    model.Total_Cost_Objective = \
        Objective(sense=minimize, expr=model.FirstStageCost + model.SecondStageCost)

    #
    # Declare that this model will have stochastic matrix entries
    # and populate the suffix information defining these locations.
    # alongside the constraint rules.
    #
    model.PySP_StochasticMatrix = Suffix()
    for i in model.CROPS:
    
        model.PySP_StochasticMatrix[model.EnforceCattleFeedRequirement[i]] = \
            [(model.DevotedAcreage[i], model.Yield[i])]

        model.PySP_StochasticMatrix[model.LimitAmountSold[i]] = \
            [(model.DevotedAcreage[i], model.Yield[i])]

    return model

def generate_scenario_tree_model(scenario_count):

    from pyomo.pysp.util.scenariomodels import generate_simple_twostage

    st_model = generate_simple_twostage(scenario_count)

    first_stage = st_model.Stages.first()
    second_stage = st_model.Stages.last()

    # First Stage
    st_model.StageCostVariable[first_stage] = 'FirstStageCost'
    st_model.StageVariables[first_stage].add('DevotedAcreage[*]')

    # Second Stage
    st_model.StageCostVariable[second_stage] = 'SecondStageCost'
    st_model.StageVariables[second_stage].add('QuantitySubQuotaSold[*]')
    st_model.StageVariables[second_stage].add('QuantitySuperQuotaSold[*]')
    st_model.StageVariables[second_stage].add('QuantityPurchased[*]')

    return st_model

def _cdf(weights):
    total = sum(weights)
    result = []
    cumsum = 0
    for w in weights:
        cumsum += w
        result.append(cumsum / total)
    return result

def _sample(table):
    population, weights = zip(*table)
    assert len(population) == len(weights)
    cdf_vals = _cdf(weights)
    x = random.random()
    idx = bisect.bisect(cdf_vals, x)
    return population[idx]

def sample_into_scenario_tree_model(reference_model, scenario_tree_model):

    sample_data = {}
    for scenario_name in scenario_tree_model.Scenarios:

        # Draw random data
        sample_data[scenario_name] = []
        for param, table in reference_model.PySP_StochasticParameters.items():
            sample_data[scenario_name].append((ComponentUID(param), _sample(table)))

    return sample_data
