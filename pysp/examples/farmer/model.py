#  _________________________________________________________________________
#
#  Pyomo: Python Optimization Modeling Objects
#  Copyright (c) 2014 Sandia Corporation.
#  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
#  the U.S. Government retains certain rights in this software.
#  This software is distributed under the BSD License.
#  _________________________________________________________________________
#
# Farmer: Generates scenario tree structure using callback
#
# Imports
#

from pyomo.core import *

#
# Model
#

model = ConcreteModel()

#
# Sets
#

model.CROPS = Set(initialize=['WHEAT', 'CORN', 'SUGAR_BEETS'])

#
# Parameters
#

model.TotalAcreage = 500.0
model.PriceQuota = {'WHEAT':100000.0,
                    'CORN':100000.0,
                    'SUGAR_BEETS':6000.0}
model.SubQuotaSellingPrice = {'WHEAT':170.0,
                              'CORN':150.0,
                              'SUGAR_BEETS':36.0}
model.SuperQuotaSellingPrice = {'WHEAT':0.0,
                                'CORN':0.0,
                                'SUGAR_BEETS':10.0}
model.CattleFeedRequirement = {'WHEAT':200.0,
                               'CORN':240.0,
                               'SUGAR_BEETS':0.0}
model.PurchasePrice = {'WHEAT':238.0,
                       'CORN':210.0,
                       'SUGAR_BEETS':100000.0}
model.PlantingCostPerAcre = {'WHEAT':150.0,
                             'CORN':230.0,
                             'SUGAR_BEETS':260.0}

model.Yield = Param(model.CROPS,
                    within=NonNegativeReals,
                    initialize=0.0,
                    mutable=True)

#
# Variables
#

model.DevotedAcreage = Var(model.CROPS,
                           bounds=(0.0, model.TotalAcreage))
model.QuantitySubQuotaSold = Var(model.CROPS,
                                 bounds=(0.0, None))
model.QuantitySuperQuotaSold = Var(model.CROPS,
                                   bounds=(0.0, None))
model.QuantityPurchased = Var(model.CROPS,
                              bounds=(0.0, None))

#
# SMPS Related Suffix Data
#

model.PySP_StochasticMatrix = Suffix()

#
# Constraints
#

def ConstrainTotalAcreage_rule(model):
    return summation(model.DevotedAcreage) <= model.TotalAcreage
model.ConstrainTotalAcreage = \
    Constraint(rule=ConstrainTotalAcreage_rule)

def EnforceQuotas_rule(model, i):
    return (0.0, model.QuantitySubQuotaSold[i], model.PriceQuota[i])
model.EnforceQuotas = Constraint(model.CROPS,
                                 rule=EnforceQuotas_rule)

#
# Constraints With Stochastic Entries
#

model.EnforceCattleFeedRequirement = Constraint(Any, noruleinit=True)
model.LimitAmountSold = Constraint(Any, noruleinit=True)
for i in model.CROPS:

    model.EnforceCattleFeedRequirement[i] = \
        (model.CattleFeedRequirement[i] <=
         (model.Yield[i] * model.DevotedAcreage[i]) + \
         model.QuantityPurchased[i] - \
         model.QuantitySubQuotaSold[i] - \
         model.QuantitySuperQuotaSold[i])
    
    model.PySP_StochasticMatrix[
        model.EnforceCattleFeedRequirement[i]] = \
            (model.DevotedAcreage[i],)

    model.LimitAmountSold[i] = \
        (model.QuantitySubQuotaSold[i] + \
         model.QuantitySuperQuotaSold[i] - \
         (model.Yield[i] * model.DevotedAcreage[i]) <= 0.0)

    model.PySP_StochasticMatrix[
        model.LimitAmountSold[i]] = \
            (model.DevotedAcreage[i],)

#
# Stage-specific cost computations
#

def ComputeFirstStageCost_rule(model):
    return summation(model.PlantingCostPerAcre, model.DevotedAcreage)
model.FirstStageCost = Expression(expr=ComputeFirstStageCost_rule)

def ComputeSecondStageCost_rule(model):
    expr = summation(model.PurchasePrice, model.QuantityPurchased)
    expr -= summation(model.SubQuotaSellingPrice, model.QuantitySubQuotaSold)
    expr -= summation(model.SuperQuotaSellingPrice, model.QuantitySuperQuotaSold)
    return expr
model.SecondStageCost = Expression(expr=ComputeSecondStageCost_rule)

#
# PySP Auto-generated Objective
#
# minimize: sum of StageCostVariables
#
# An active scenario objective equivalent to that generated by PySP is
# included here for informational purposes.
def total_cost_rule(model):
    return model.FirstStageCost + model.SecondStageCost
model.Total_Cost_Objective = Objective(rule=total_cost_rule,
                                       sense=minimize)


#
# Define PySP callbacks and per-scenario stochastic data
#

PerScenarioYield = {}
PerScenarioYield['Scenario1'] = \
    {'WHEAT':2.0, 'CORN':2.4, 'SUGAR_BEETS':16.0}
PerScenarioYield['Scenario2'] = \
    {'WHEAT':2.5, 'CORN':3.0, 'SUGAR_BEETS':20.0}
PerScenarioYield['Scenario3'] = \
    {'WHEAT':3.0, 'CORN':3.6, 'SUGAR_BEETS':24.0}

def pysp_scenario_tree_model_callback():
    from pyomo.pysp.util.scenariomodels import generate_simple_twostage

    st_model = generate_simple_twostage(len(PerScenarioYield))

    first_stage = st_model.Stages.first()
    second_stage = st_model.Stages.last()

    # First Stage
    st_model.StageCostVariable[first_stage] = 'FirstStageCost'
    st_model.StageVariables[first_stage].add('DevotedAcreage[*]')

    # Second Stage
    st_model.StageCostVariable[second_stage] = 'SecondStageCost'
    st_model.StageVariables[second_stage].add('QuantitySubQuotaSold[*]')
    st_model.StageVariables[second_stage].add('QuantitySuperQuotaSold[*]')
    st_model.StageVariables[second_stage].add('QuantityPurchased[*]')

    return st_model

def pysp_instance_creation_callback(scenario_name, node_names):

    instance = model.clone()
    instance.Yield.store_values(PerScenarioYield[scenario_name])

    return instance

